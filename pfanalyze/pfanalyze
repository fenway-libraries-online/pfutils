#!/usr/bin/perl

use strict;
use warnings;

use POSIX qw(strftime);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

# State -- queued or done
use constant QUEUED   => 'Q';
use constant NOQUEUE  => 'N';
use constant DONE     => 'D';

$| = 1;

my $year = (localtime)[5] + 1900;
my $only_domain;
my ($show_jobs, $show_only_jobs, $parseable);

GetOptions(
    'd|domain=s' => \$only_domain,
    'y|year=i' => \$year,
    'j|show-jobs' => \$show_jobs,
    'J|show-only-jobs' => sub { $show_jobs = $show_only_jobs = 1 },
    'p|parseable' => \$parseable,
    'V|version' => sub {
        print <<'EOS';
pfgrep __VERSION__ by __AUTHOR__
__COPYRIGHT__
EOS
        exit 0
    },
) or usage();

my %mon2num = qw(
    Jan  1      Feb  2      Mar  3
    Apr  4      May  5      Jun  6
    Jul  7      Aug  8      Sep  9
    Oct 10      Nov 11      Dec 12
);

my %job;
my ($from, $to);
my $last_timestamp = 0;

$SIG{'HUP'} = \&show_jobs;

while (<STDIN>) {
    my $line = parse($_);
    my ($qid, $from, $to, $timestamp) = @$line{qw(qid from to timestamp)};
    if ($line->{'removed'}) {
        my $qid = $line->{'qid'};
        my @keys = grep { /^$qid:/ } keys %job;
        my @jobs = delete @job{@keys};
        next if !@jobs;
        if (!$show_only_jobs) {
            output(DONE, $_, $timestamp) for @jobs;
        }
        $last_timestamp = $timestamp;
    }
    elsif ($qid eq 'NOQUEUE') {
        my ($started, $status, $dsn) = @$line{qw(started status dsn)};
        for ($from, $to, $started, $status, $dsn) {
            $_ = '-' if !defined $_;
        }
        output(NOQUEUE, [ 'n/a', $from, $to, $started, $status, $dsn ], $timestamp);
    }
    if (!defined $to) {
        next;
    }
    else {
        my $status = $line->{'status'} || next;
        my ($user, $domain) = @$line{qw(user domain)};
        if (!defined $only_domain || $domain eq $only_domain) {
            my $key = $line->{'key'};
            if (defined $job{$key}) {
                $job{$key}->[4] = $status;
                $job{$key}->[5] = $line->{'dsn'} || '0.0.0';
            }
            else {
                $job{$key} = [ $qid, $from, $to, $timestamp, $status, $line->{'dsn'} || '0.0.0' ];
            }
        }
        $last_timestamp = $timestamp;
    }
}
show_jobs() if $show_jobs;

# --- Functions

sub show_jobs {
    print "{\n";
    output(QUEUED, $_, $last_timestamp) for values %job;
    print "}\n";
}

sub timestamp {
    return strftime('%s', localtime) if !@_;
    my ($Y, $m, $d, $H, $M, $S) = @_;
    my $t = strftime('%s', $S, $M, $H, $d, $mon2num{$m}-1, $Y-1900);
    my $td = $t - time();
    if ($td > 86400 * 31) {
        $t = timestamp($year - 1, $m, $d, $H, $M, $S);
    }
    return $t;
}

sub output {
    my ($state, $job, $timestamp) = @_;
    my ($qid, $from, $to, $started, $status, $dsn) = @$job;
    my $delay = defined($started) ? $timestamp - $started : 0;
    if ($parseable) {
        printf "%s %s %s %d %s %s %s\n",
               $state, $dsn, $qid, $delay, ymdhms($timestamp), $from, $to;
    }
    else {
        printf "%s %s %s %6dm %-19.19s %s\n".
               "%53.53s %s\n",
               $state, $dsn, $qid, int($delay/60), ymdhms($timestamp), $from, chr(96)."->", $to;
    }
    #print "$state $dsn $qid $started $timestamp $user $domain\n";
}

sub ymdhms {
    my ($s) = @_;
    return '????-??-?? ??:??:??' if !defined $s;
    strftime('%Y-%m-%d %H:%M:%S', localtime $s);
}

sub parse {
    local $_ = shift;
    my %line;
    my ($mon, $day, $time, undef, undef, $qid, $etc) = split /\s+/, $_, 7;
    $qid =~ s/:$//;
    $line{'qid'} = $qid;
    my $timestamp = $line{'timestamp'} = timestamp($year, $mon, $day, (split /:/, $time));
    $line{'status'} = $1 if s/status=(\S+)//;
    if ($etc eq 'removed') {
        $line{'removed'} = 1;
    }
    elsif ($qid eq 'NOQUEUE') {
        $line{'noqueue'} = 1;
        my ($from, $to, $status, $dsn);
        $from = $1 if /[:,;<>] from=<([^<>]*)>/;
        $to = $1 if /[:,;<>] to=<([^<>]*)>/;
        ($status, $dsn) = ($1, $2) if /NOQUEUE: [^:]+: [^:]+: (\d\d\d) (\d+\.\d+\.\d+)/;
        @line{qw(from to status dsn started)} = ($from, $to, $status, $dsn, $timestamp);
    }
    while ($etc =~ s/(.+?)=(\S+?), //) {
        $line{$1} = $2;
    }
    s/^<|>$//g for grep { defined $_ } @line{qw(to orig_to)};
    $to = $line{'to'};
    foreach ($from, $to) {
        $_ = '?'  if !defined $_;
        $_ = '<>' if !length $_;
    }
    my ($user, $domain) = split /\@/, $to;
    $domain = '.' if !defined $domain || !length $domain;
    $domain = lc $domain;
    $line{'user'} = $user;
    $line{'domain'} = $domain;
    $line{'key'} = $qid . ':' . $user . '@' . $domain;
    $line{'dsn'} ||= '0.0.0';
    return \%line;
}
